========================== Безопасность API и системный анализ ============================
https://dion.vc/video/864eab22-f3c0-42cb-a751-57f2717f4dc4?ref_uid=4fa0a022-9be1-4520-9fba-24391f18a066 
Основные угрозы безопасности.
ИСТОЧНИКИ УГРОЗ
1. Неавторизованный доступ к API:
Если API не имеет надежной системы аутентификации и авторизации, злоумышленники могут получить
доступ к конфиденциальным данным и критически важным функциям.
2. Утечки данных из-за недостаточной валидации запросов:
Некорректно обработанные входные данные могут привести к утечкам информации, SQL инъекциям и другим атакам, направленным на получение конфиденциальных сведений.
3. Атаки типа (MITM):
Без надежного шифрования злоумышленники могут перехватить данные, передаваемые между клиентом и сервером API, включая учетные данные пользователей и другие критически важные данные.
4. Атаки с повышением привилегий: 
Если API не проверяет уровень доступа пользователей, атакующий может воспользоваться уязвимостью
для получения административных прав или доступа к чужим данным.
5. DDoS атаки и чрезмерные запросы:
Злоумышленники могут перегрузить API большим количеством запросов, что приведет к отказу в 
обслуживании и недоступности сервисов.

----------- Идентификация -----------------------------------------------------------
— это процесс при котором система узнаёт, кто перед ней, присваивая уникальный идентификатор (Логин, email) Цель — получить уникальный идентификатор. 

----------- Аутентификация ----------------------------------------------------------
— это процесс подтверждение личности пользователя или клиента перед предоставлением доступа к защищённым ресурсам API. Цель — убедиться, что идентификатор не подделан (Пароль, одноразовый код, аппаратный токен, биометрия). Виды:
	Однофакторная аутентификация (небезопасно)
	Многофакторная MFA: Двухфакторная, Трёхфакторная (безопасно)
Типы:
Методы аутентификации: 
	Токен:	
		Basic Authentication (Base64)
		Bearer token
		API Key Authentication
	Сетевые:	
		kerberos
		TLS
		OAuth/OpenID Connect
		Сертификаты

---------- Авторизация authorization — «разрешение; полномочивание» --------------------------------
 — предоставление определённому лицу или группе лиц прав, после аутентификации, на выполнение определённых действий, а также процесс проверки (подтверждения) этих прав при попытке выполнения указанных действий. Цель - ограничить доступ к ресурсам, согласно ролевой модели.
	
=========== Ролевые модели доступа ================================================================
----------- RBAC ----------------------------------------------------------------------------------
Role-Based Access Control	 — модель управления доступом, основанная на ролях пользователей в организации. Вместо индивидуального назначения привилегий каждому пользователю права доступа группируются по ролям, а пользователи получают доступ к ресурсам уже в зависимости от своей роли. Цель RBAC — централизованно контролировать права пользователей, минимизировать риски несанкционированного доступа и упрощать администрирование учётных записей.
Аналитик 	- видит отчёты;
Бухгалиер 	- доступны проводки и их отчёты;
Менеджер	- просмотр;
Администратор	- редактирование.
Студент 	- может брать книги;
Сотрудник	- редактировать.

----------- ABAC ----------------------------------------------------------------------------------
Attribute-Based Access Control	— модель управления доступом на основе атрибутов. Она определяет права доступа на основе характеристик (атрибутов) пользователя, ресурса, действия и окружения. Атрибуты могут относиться к разным категориям: 	
	Субъекты 	— пользователи, которые запрашивают доступ.
	Ресурсы 	— файлы, базы данных, API или другие системные сущности.
	Действия	— конкретная операция, которую субъект может выполнить над ресурсом (создание, чтение, обновление, удаление).
	Окружение	— контекст, в котором делается запрос на доступ (время суток, местоположение, сеть, устройство и т. д.).
Врач может видеть карту пациента, например, только:
		-в рабочие часы;
		-с рабочего места;
		-прикреплённых к нему пациентов.
Доступ к данным пользователя (клиента) только:
		-с закреплённого устройства;
		-при активном трудовом договоре.

============ Token = ключ ==================================================================================
------------ Basic Authentication...................HTTP(s)/REST-протоколы, когда пара "ключ-значение" передаются в Header: Authorization: как AuBase64. Сервер декодирует и решает дать доступ. Нет механизма отзыва доступа, кроме смены пароля. Для тестирования.;

------------ Single Page Application (SPA)..........это тип веб-приложения, которое загружает одну страницу и динамически обновляет контент в ответ на действия пользователя. В отличие от традиционных многостраничных приложений, где каждый переход между страницами требует полной перезагрузки, SPA обеспечивают плавный и непрерывный пользовательский опыт. Bearer token имеет не самый высокий уровень безопасности.

------------ Access token...........................это ваша пропускная карта в здание. Токен доступа. Она дает вам доступ в определенные помещения (ресурсы) на ограниченное время. Это основной ключ для доступа к защищенным ресурсам (например, API, данным пользователя).
	Назначение: Доказать, что у пользователя есть право доступа к определенным данным или функциям.
	Содержимое: Обычно содержит информацию о пользователе (ID, роли, "scope" — области доступа) и срок действия.
	Время жизни: Короткое — от нескольких минут до нескольких часов. Это мера безопасности. Даже если токен перехватят, злоумышленник сможет им пользоваться недолго.
	Передача: Передается клиентом (например, фронтенд-приложением) на сервер с каждым запросом к защищенному ресурсу.
	Пример:
		http
		GET /api/user/profile
		Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
		(Здесь eyJhbGci... — это и есть Access Token)

------------ Bearer token............................тип Access Token. Спец.ключ, который предоставляется пользователю сервером, после успешной аутетификации. Токен-носитель. Используется для доступа к защищённым API. Передаётся в Header: Authorization: - сервер проверяет ключ на валидность. Токен можно отозвать сервером. Мобильные приложения. Это тип этой пропускной карты, который работает по принципу "предъявительский". Тот, у кого она находится, получает доступ. Не важно, кто он. Это не отдельный тип токена, а способ его использования. Это самый распространенный тип Access Token. String - буквенно-числовой код одним блоком.
	Назначение: Определить схему аутентификации. Слово "Bearer" (предъявитель) означает, что для доступа к ресурсу достаточно просто предъявить этот токен.
	Ключевая особенность: Отсутствие криптографической проверки предъявителя. Тот, у кого есть этот токен, считается законным владельцем. Это одновременно и простота, и главный риск — если токен утек, злоумышленник может использовать его, пока он не истек.
	Стандарт: Описан в RFC 6750. Передается в заголовке Authorization: Bearer <token>.
	Вывод: Access Token часто (в 99% случаев в современных API) является Bearer Token'ом. "Bearer" — это просто уточнение, как использовать Access Token.

------------ API Key Authentication..................метод аутентификации в API, при котором клиент отправляет уникальный API-ключ вместе с каждым запросом к серверу. Это идентификатор, предоставляемый сервером клиенту для доступа к ресурсам API. Обычно это длинная алфавитно-цифровая строка, сгенерированная провайдером API и выданная разработчикам или приложениям, нуждающимся в доступе к API. По уровню безопасности = Basic Authentication. Скорость внедрения и тетсирования API.

------------ Refresh token...........................это инструмент для продления жизни сессии, позволяющий безопасно обновлять короткоживущие Access Token'ы. Токен обновления в системах авторизации, например OAuth 2.0 и OpenID Connect. Это символьная строка, которая выдаётся клиенту сервером авторизации и используется для получения нового токена доступа, когда текущий токен доступа становится недействительным или истекает его срок действия. Имеет повышенный TTL с токенами, которыми работает в паре (Access token "Bearer token"). Ближе к истечению срока действия token, по протоколу OAuth2, клиент запрашивает у сервиса аутентификации (типа Google, Yandex) новкю пару, это происходит незаметно для пользователя "под капотом". это ваш паспорт в охране. Вы не ходите с ним по офису, но когда ваша пропускная карта (Access Token) просрочилась, вы предъявляете паспорт, чтобы получить новую карту. Это долгоживущий ключ, единственная цель которого — получить новый Access Token.
	Назначение: 		Позволить пользователю получить новый Access Token без необходимости повторного ввода логина и пароля.
	Время жизни: 		Долгое — от нескольких дней до нескольких месяцев. Может быть и вовсе бессрочным, но это небезопасно.
	Хранение и передача: 	Хранится максимально безопасно (например, в httpOnly куках на клиенте) и передается только на специальный эндпоинт /token для получения новой пары токенов (Access + Refresh).
	Безопасность: 		Поскольку его время жизни велико, он гораздо ценнее для злоумышленника. Если он скомпрометирован, атакующий может получать новые Access Token'ы от имени пользователя неограниченное время.
Как они работают вместе (Типичный поток OAuth 2.0 / OpenID Connect) Вход: Пользователь вводит логин/пароль в клиентском приложении.
	Аутентификация: 	Клиент отправляет учетные данные на сервер авторизации.
	Получение токенов: 	Сервер проверяет данные и возвращает объект с двумя токенами:
	json
	{
	  "access_token": "eyJhbGci...", 	// Короткоживущий Access Token (Bearer)
	  "refresh_token": "def50200...", 	// Долгоживущий Refresh Token
	  "token_type": "Bearer",
	  "expires_in": 3600 			// Access Token истечет через час
	} 
	Доступ к API: 		Клиент использует access_token (как Bearer Token) для доступа к API.
	Истечение Access Token:	Через час (или иное время) Access Token становится недействительным. API начнет возвращать ошибку 401 Unauthorized.
	Обновление: 		Клиент не беспокоит пользователя, а отправляет refresh_token на специальный эндпоинт.
	Получение новой пары:	Сервер авторизации проверяет refresh_token и, если он валиден, выдает новую пару access_token и, иногда, новый refresh_token (ротация токена для безопасности).
	Цикл повторяется: 	Клиент снова может работать с API, используя новый access_token.
	Задачи:
		Продление сессии 		— позволяет поддерживать активную сессию пользователя, не требуя повторного ввода учётных данных.
		Повышение безопасности 		— токены доступа имеют короткий срок действия, что снижает риск их использования при утечке, а токен обновления позволяет безопасно получать новые токены доступа.
		Гибкость управления доступом 	— может использоваться для получения токенов доступа с различными областями видимости (scopes), что позволяет точно настраивать права доступа.

------------ JWT - JSON Web Token.....................Безопасный вариант ключа. Компактный и самодостаточный способ безопасной передачи информации между сторонами в виде подписанного JSON-объекта. String - буквенно-числовой код, тремя блоками, разделёнными точкой. Токен JWT состоит из трёх частей, разделённых точками: 
					Заголовок (header) 		— указывает тип токена и алгоритм подписи (например, HS256 или RS256);
					Полезная нагрузка (payload) 	— содержит утверждения (claims) — фактические данные, которые передаются в токене. Это могут быть стандартные поля и информация о пользователе; 
					Подпись (signature) 		— создаётся на основе первых двух частей и секретного ключа, который знает только сервер. Работает следующим образом:
									Пользователь 	отправляет данные для входа (логин и пароль) на сервер;
									Сервер		проверяет данные и, если всё в порядке, генерирует ключ в формате JSON, подписанный секретным ключом;
									Клиент		JWT возвращается пользователю, который хранит его (чаще всего, в localStorage или cookie). 
									Клиент		Отправляет токен в заголовке Authorization: Bearer abc123...
									Сервер		проверяет подпись и данные в ключе.
	Компактность 		— JWT представляет собой строку, которая легко передаётся через URL, заголовки HTTP или в теле запроса.
	Самодостаточность 	— весь «контекст» (например, данные о пользователе) содержится внутри токена. Можно передавать дополнительные данные, например user_id;
		Stateless	- не требует хранения состояния на сервере;
		Минусы		- нельзя отозвать (-)
		Минусы		- если ключ подписи скопроментирован, то и токены JWT можно подделать (-)

============ Протоколы =====================================================================================
------------ OAuth - Open Authorization...............это открытый стандарт авторизации, который позволяет приложениям получать ограниченный доступ к данным пользователя на других сервисах без необходимости сообщать свои логин и пароль. Простыми словами: OAuth действует как посредник от имени пользователя, предоставляя стороннему сервису (зарегистрированному на сервере, например, через: Goole, Yandex) токен доступа (access token), который разрешает передачу определённой информации об учётной записи. 

------------ Kerberos................................сетевой протокол аутентификации, разработанный в Массачусетском технологическом институте (MIT) для проекта «Афина» в конце 1980-х годов. От слова "Цербер" - трёхголовый пёс. Позволяет клиентам и серверам безопасно проверять подлинность друг друга с помощью Центра распределения ключей (KDC) — доверенной третьей стороны. Kerberos использует симметричное шифрование и обеспечивает защиту от прослушивания и повторных атак (replay attacks) в системах Windows. Для аутентификации используются временные билеты (Ticket Granting Ticket, TGT). Каждый билет принадлежит определённым реалмам, которые определяют, к каким сервисам он предоставляет доступ. Шаги протокола:
		Пользователь		вводит свой логин и пароль;
		KDC			выдаёт "билет на получение билета", TGT;
		ИС-Клиент		используя TGT запрашивает доступ к ИС-сервер у KDC;
		KDC			выдаёт TGS-Ticket Granting Service, сервисный билет;
		ИС-Клиент		предъявляет сервисный билет ИС-сервер и получает доступ без повторного ввода пароля.Особенности:
			Пароли не передаются по сети, используются временные билеты.
			Единый вход (SSO) — после получения TGT пользователь может обращаться к разным сервисам без повторной аутентификации.
			Поддержка взаимной аутентификации — не только клиент, но и сервер может проверить подлинность друг друга.

------------ TLS - Transport Layer Security..........криптографический протокол, который защищает данные во время их передачи по сети. Работает на четвёртом, транспортном, уровне сетевой модели OSI. Рукопожате-handshake. UDP-это "стеклянная" труба, TCP-это "не прозрачная" труба, шифрованный туннель. Функции TLS обеспечивает три основных аспекта безопасности: 
		Конфиденциальность — 		защита передаваемой информации от несанкционированного доступа (шифрование данных);
		Целостность — 			гарантия, что передаваемая информация не была изменена в процессе передачи;
		Аутентификация — 		проверка подлинности сторон, участвующих в коммуникации, чтобы убедиться, что общение происходит с правильным сервером, а не с злоумышленником. Работает так:
			Установление TCP-соединени;
			ИС-Клиент подключается к ИС-сервер;
			Совершается Рукопожате-handshake TLS;
			Происходит обмен ключами;
			Создаётся защищённый канал;
			после всего, по каналу- передача данных, в зашифрованном виде. Каждая "посылка" - это отдельная коробка со своим ключом.

------------ SAML & OAuth................................
(Security Assertion Markup Language) и OAuth (Open Authorization) — протоколы аутентификации и авторизации пользователей, но имеют разные цели и особенности. 
SAML 		фокусируется на АУТЕНТИФИКАЦИИ, упрощает процесс входа в систему, позволяя пользователям входить с одним набором учётных данных и получать доступ к нескольким системам без необходимости каждый раз вводить учётные данные. 
SAML		работает путём отправки информации об АУТЕНТИФИКАЦИИ в определённом формате между поставщиком идентификационных данных (IdP) и веб-приложением. 
OAuth 		предназначен для АВТОРИЗАЦИИ, помогает защитить учётные данные при предоставлении общего доступа приложениям, таким как платформы социальных сетей или сторонние сервисы. OAuth 		использует токены и параметры запроса scope для АВТОРИЗАЦИИ пользователей. Если пользователь разрешает приложению доступ к его данным, оно получает токен доступа, который позволяет приложению видеть сведения без необходимости ввода учётных данных. 
Некоторые различия между SAML и OAuth:
ФОРМАТ ДАННЫХ: 			
SAML 		используются утверждения на основе XML, содержащие подробные атрибуты пользователя. 
OAuth 		для представления данных используется формат JSON, а не XML. 
МОДЕЛЬ БЕЗОПАСНОСТИ:
SAML 		использует цифровые подписи и утверждения для защиты данных;
OAuth 		полагается на токены доступа. 
УПРАВЛЕНИЕ СЕАНСАМИ:
SAML 		создаёт сеансы браузера и обрабатывает вход в систему в нескольких приложениях. После входа в приложение с помощью IdP создаётся сеанс, который позволяет получить доступ к нескольким приложениям без необходимости каждый раз вводить учётные данные. 
СЛОЖНОСТЬ ВНЕДРЕНИЯ: 
SAML 		сложнее внедрить, чем OAuth. 
SAML 		опирается на утверждения для проверки личности пользователей и требует одновременной работы нескольких систем, для чего нужна сложная настройка для обеспечения соответствующей аутентификации пользователей. 
ПРИМЕНЕНИЕ:
SAML 		используется для единого входа (SSO) в корпоративных средах, позволяя пользователям аутентифицироваться один раз и получать доступ к нескольким приложениям. 
OAuth		применяется для авторизации и делегирования доступа, например, для предоставления доступа сторонним приложениям к данным пользователя без раскрытия учётных данных. 
SAML и OAuth могут работать вместе в системах, требующих как АУТЕНТИФИКАЦИИ, так и АВТОРИЗАЦИИ. Например, сотрудник может войти в корпоративную систему с помощью SAML, но затем система выдаёт токен доступа OAuth, чтобы он мог взаимодействовать с внешними сервисами или API, такими как Microsoft Graph или Google Drive. 


============== Парольные политики ========================================================================================



