В данном интенсиве будет 1 вебинар. 
Вы получите доступ к курсу на корпоративной платформе Basecode, где будут материалы к интенсиву.
В тг создана ссылка на чат, общий для всех интенсивов: https://t.me/+PtqjrExYs5RkNmYy 
-------------------------------------------------------------------------------------
https://basecode.t1.ru/viewer/sessions/6020/quizzes/1034 
https://basecode.t1.ru/viewer/sessions/6020/materials/12633
вебинар Безопасность и системный ананлиз https://dion.vc/video/864eab22-f3c0-42cb-a751-57f2717f4dc4?ref_uid=4fa0a022-9be1-4520-9fba-24391f18a066
-------------------------------------------------------------------------------------
Дядюра Сергей Станиславович SDyadyura@inno.tech Отдел образовательных проектов	Цифровая академия
Баранова Анна Делмуховна adbaranova@inno.tech	Отдел архитектуры и аналитики	Центр архитектуры и обеспечения качества
========================================================================================================================
Основы архитектурного стиля REST.API (не SOAP.API стиль) использует 	HTTP(S), но не только, - могут быть:
									WebSockets - сетевой протокол, обеспечивающий двустороннюю связь между клиентом и сервером в реальном времени. В отличие от традиционного HTTP-протокола, WebSocket не требует повторного открытия соединения для каждой передачи данных. или используются:
									самописные протоколы.
================ REST API Pooling ==========================================================
передача состояния представления.
REST (Representational State Transfer) — архитектурного стиля взаимодействия между клиентом и сервером через HTTP. Принципы архитектуры REST API определяют структуру взаимодействия между клиентом и сервером, а также позволяют расширять функциональность клиента. Некоторые из них:
		 Client-Server. Клиент-серверная архитектура. Клиент запрашивает данные, а сервер их предоставляет. Такое разделение улучшает масштабируемость системы и позволяет клиентам работать независимо от серверной логики. 
		 Stateless. Отсутствие состояния. Каждый запрос от клиента к серверу обрабатывается независимо от предыдущих запросов. Сервер не хранит информацию о состоянии клиента, что упрощает обработку запросов и повышает отказоустойчивость системы. Request содержит полноту запроса, т.к. сервис не хранит историю.
		Cacheable. Кеширование. Ответы сервера могут кэшироваться, чтобы снизить нагрузку на сервер и ускорить загрузку данных. REST поддерживает механизмы кеширования, которые позволяют клиентам повторно использовать ранее полученные данные. 
		 Uniform Interface. Единообразие интерфейса. Все ресурсы REST должны иметь чёткую структуру и единообразные URL-адреса. Запросы к API выполняются с использованием стандартных методов HTTP, а данные передаются в предсказуемых форматах, таких как JSON или XML. 
		 Layered System. Система уровней, Слои. REST может включать несколько уровней, таких как балансировщики нагрузки, прокси-серверы и системы аутентификации. Каждый уровень выполняет свою функцию и не зависит от других, что повышает надёжность и гибкость системы. Означает, что сервер разделён на несколько слоёв, каждый из которых выполняет свою задачу. Например: 
		-	один слой может отвечать за обработку запросов;
		-	другой — за аутентификацию;
		-	третий — за обработку базы данных и так далее. , Code on Demand
		Code on Demand. Возможность выполнения кода по требованию. Хотя этот принцип не является обязательным, REST может поддерживать загрузку и выполнение кода на стороне клиента, например в виде скриптов или небольших программ. опционально. Сервер может отправлять исполнимый код (например, JavaScript) на клиент для выполнения. Это позволяет: 
		-	Временно расширить или настроить функциональность клиента — вместо отправки просто данных сервер может передавать логику. 
		-	Передавать целые сценарии — например, динамические элементы пользовательского интерфейса, выполненные на JavaScript. 

Sync/Async взаимодействие

-------------- Cookie (куки) -----------------------------------------------------------
— это небольшие фрагменты данных, которые веб-сайт сохраняет на устройстве пользователя (компьютере, смартфоне, планшете) при его посещении. Некоторые функции cookie:
		Персонализация интерфейса. Сайты запоминают язык, тему оформления, регион, валюту и другие пользовательские настройки.
		Аутентификация и безопасность. Cookie позволяют сохранять состояние входа в систему, чтобы не приходилось вводить логин и пароль каждый раз. Также они помогают отслеживать подозрительную активность и предотвращать несанкционированный доступ.
		Аналитика и статистика. Инструменты, такие как Google Analytics или Яндекс.Метрика, используют cookie для сбора данных о посещениях: сколько пользователей зашло, какие страницы они смотрели и сколько времени провели на сайте.
		Рекламный таргетинг. На основе куки-файлов рекламные сети показывают персонализированную рекламу — ту, которая потенциально может заинтересовать пользователя.

--------------- webhook => url --------------------------------------------------------
— это механизм автоматической отправки данных между приложениями при наступлении определённого события. Простыми словами, это способ одной программы сказать другой: «Эй, тут кое-что произошло, думаю, тебе стоит об этом знать!». В отличие от традиционного API, где клиент постоянно отправляет запросы, вебхуки позволяют серверу сразу уведомлять получателя при возникновении события. Механизм вебхука можно описать тремя шагами: 
	Событие:			в приложении-источнике.
	Сервис отправляет HTTP-запрос: 	на заранее указанный URL — это и есть вебхук-адрес. Чаще всего используется метод POST, данные передаются в теле запроса в формате JSON, XML или form-encoded.
	Приложение-получатель:		принимает этот HTTP-запрос, обрабатывает данные и обычно возвращает технический ответ (статус «200 OK»).



================ Структура REST.API request ======================================================
Стартовая строка (Request Line):
PUT		- тип метода
https://	- протокол
vtb.ru/		- домен
/ui-api-mi/	- каталог API
/kib/		- название сервиса или папки
/v1/		- версия
/project/	- endpoint
/{id}		- path param

Версонированинность:
	частоиспользуемый:	
		/v1/users или
		/api/v3/order
	через заголовки:
		Accept: application/vnd.myapi.v1+json или кастомный заголовок 
		X-API-Version:2
	через параметры запроса: 
		/users?version=1 или 
		/api/resource?api-version=2
	контентное: application/vnd.example.v1+json
Обратная совместимость (backward compability) -это способность системы взаимодействовать с предыдущими версиями API, данных или программного обеспечения. Например, новое обновление сервиса должно работать с клиентами, которые используют старую версию API.

------------- headers ---------------------------------------------------------------------
не являются частью URL-адреса (endpoint), но содержат дополнительную информацию о запросе и ответе. Заголовки — это метаданные, которые передаются в HTTP-коммуникации, и они включены в сообщения запроса и ответа, отдельно от фактического содержимого запроса и ответа. Заголовки Headers — это пары «ключ-значение», где ключ — строка, описывающая тип информации, а значение — фактические данные. 
Структура REQUEST:
	Header:
		Host: example.com
		User Agent: Mozilla/5.0			-идентифицирует программное обеспечение клиента, отправляющего запрос;
		Authorization: Bearer abc123...		-используется для передачи информации об аутентификации, например, токена доступа или ключа API.
		X-API-Key:				—это нестандартный HTTP-заголовок, который используется для аутентификации и авторизации запросов к API. Он представляет собой уникальный идентификатор, связанный с клиентом API, и передаётся в запросе вместе с другими данными. В некоторых случаях ключ передаётся в GET-параметре, например, ?apikey=
		Content-Type: application/ json		-указывает на формат тела запроса
				JSON
					Легче и компактнее
					Проще читать и разбирать
					Быстрее парсится
					Стандарт де факто для REST
				XML
					Сложные документные структуры
					Богатые схемы	
					Наследие и стандарты
		Query params:	(параметры запроса) это часть URL, которая позволяет передавать дополнительные данные серверу для фильтрации, сортировки, пагинации и других операций. Они добавляются в конец URL после знака вопроса ? и разделяются амперсандами &.
			Пагинация			GET .../puppies?page=2&per_page=20
			Фильтрация данных		GET .../puppies?breed=yorkshire
			Сортировка			GET .../puppies?sort=age_asc
			Поиск				GET .../puppies?search=query
			Авторизация и аутентификация 	GET .../puppies?token=abc123
			URL				GET .../puppies?url=yandex.ru
		Path params:
	Body:
		API-Key:

================ Структура RESPONSE ==========================================================
	Статусная строка (Status Line):
		Code HTTP		200 OK
			Код статуса 	(200) значение, которое говорит об успехе или ошибке
			Текст статуса 	( OK) пояснение к коду.
		Версия протокола 	HTTP/1.1.
	Header:	
		Content-Type:	тип данных в теле ответа.
		Server:		какое ПО работает на сервере.
		Set-Cookie:	куки, которые сервер просит сохранить
	Body:
		{
		"id":1
		"name": “Бруно",
		“age ": 14
		}
МЕТОДЫ: 
	POST	-Применяется для создания нового ресурса на сервере. Данные отправляются в теле запроса.
	PUT	-Используется для полного обновления существующего ресурса. Сервер полностью заменяет существующий ресурс на новый.
	PATCH	-Предназначен для частичного обновления ресурса. В отличие от метода PUT, который полностью заменяет ресурс, PATCH позволяет изменять только указанные поля, оставляя остальные нетронутыми.
	GET	-Используется для запроса информации о ресурсе. Не изменяет данные на сервере, многократные идентичные запросы дают одинаковый результат. Использование ключа API-Key в GET-параметре, например, ?apikey=
	OPTIONS	-запрашивает разрешённые варианты коммуникации для данного URL или сервера. Он не используется для манипуляций с ресурсами, но полезен для: 
		...Проверки разрешённых HTTP-методов для ресурса.
		...Получения информации о поддерживаемых заголовках и других возможностях.
		...Тестирования доступности API без выполнения реальных операций.
		...Предполётных запросов (preflight) в механизме CORS (Cross-Origin Resource Sharing) для кросс-доменных взаимодействий. Браузер автоматически отправляет preflight OPTIONS-запрос перед «сложными» кросс-доменными запросами.
	HEAD	-Запрашивает метаданные ресурса в виде заголовков, но не возвращает фактическое содержание ресурса (тело ответа). Это позволяет получить метаданные, не загружая сам контент. Особенности:
		...Безопасный — не изменяет состояние сервера. 
		...Идемпотентный — многократные идентичные запросы дают одинаковый результат.
	DELETE	-Применяется для удаления ресурса. При получении DELETE-запроса сервер удаляет указанный ресурс (например, запись, файл, элемент).

----------------- CRUD: Create-Read-Update-Delete -------------------------------------------
Функции методов. Каждый метод выполняет определённое действие и соответствует принципам:	
	
----------------- Идемпотентность (idempotency) в контексте REST API ------------------------
— это свойство некоторых HTTP-методов, при котором повторные идентичные запросы имеют тот же эффект, что и один запрос. Для реализации идемпотентности в REST API используются, например:
		Заголовок Idempotency-Key — клиент генерирует для каждой операции уникальный ключ и передаёт его в заголовке. Сервер, видя повторный ключ, не выполняет операцию заново, а возвращает сохранённый результат.
		Уникальные бизнес-ключи — от клиента требуется передача уникального идентификатора операции в теле запроса (например, transactionId). Сервер проверяет уникальность этого ключа в базе данных перед выполнением операции.
	
==================== коды HTTP ответов ===================================
200 ОК
201 Создано
204 Нет контента
206 Частичное содержимое
--------- ошибки клиента -----------------
400 Плохой запрос
401 Не авторизован
403 Доступ запрещен
404 Не найдено
409 Конфликт
429 Слишком много запросов
--------- ошибки сервера -----------------
500 Внутренняя ошибка сервера
502 Плохой шлюз
503 Сервер не доступен
504 Таймаут шлюза

===================== Swagger ===================================================
			— это набор инструментов с открытым исходным кодом для разработки, документирования и тестирования API. Он помогает разработчикам создавать, описывать и проверять программные интерфейсы, делая их понятными для разработчиков и конечных пользователей. Swagger работает на основе спецификации OpenAPI, которая описывает структуру API: маршруты, методы, параметры и ответы. 
Функции:
	Автоматическая генерация документации. 		-для API на основе спецификации OpenAPI. Включает информацию о доступных методах, параметрах, типах данных и возвращаемых значениях. 
	Визуализация API 				-отображение методов, параметров, запросов и ответов в удобном интерфейсе. 
	Тестирование API 				-возможность вызывать методы прямо из браузера. 
	Генерация кода					-создание клиентских SDK, серверных заглушек и DTO по спецификации. 
	Поддержка версионности				-удобное управление версиями API и изменениями. 

Компоненты. Некоторые инструменты Swagger:
	Swagger Editor 			— онлайн-редактор для написания документации в формате OpenAPI (YAML или JSON).
	Swagger UI 			— визуальный интерфейс для просмотра и тестирования API в браузере.
	Swagger Codegen 		— генератор клиентского кода и серверных заглушек на различных языках программирования.
	Swagger Inspector 		— инструмент для автоматической генерации спецификаций API на основе реальных запросов.

========================== Безопасность API и системный анализ ============================
https://dion.vc/video/864eab22-f3c0-42cb-a751-57f2717f4dc4?ref_uid=4fa0a022-9be1-4520-9fba-24391f18a066 
Основные угрозы безопасности.
ИСТОЧНИКИ УГРОЗ
1. Неавторизованный доступ к API:
Если API не имеет надежной системы аутентификации и авторизации, злоумышленники могут получить
доступ к конфиденциальным данным и критически важным функциям.
2. Утечки данных из-за недостаточной валидации запросов:
Некорректно обработанные входные данные могут привести к утечкам информации, SQL инъекциям и другим атакам, направленным на получение конфиденциальных сведений.
3. Атаки типа (MITM):
Без надежного шифрования злоумышленники могут перехватить данные, передаваемые между клиентом и сервером API, включая учетные данные пользователей и другие критически важные данные.
4. Атаки с повышением привилегий: 
Если API не проверяет уровень доступа пользователей, атакующий может воспользоваться уязвимостью
для получения административных прав или доступа к чужим данным.
5. DDoS атаки и чрезмерные запросы:
Злоумышленники могут перегрузить API большим количеством запросов, что приведет к отказу в 
обслуживании и недоступности сервисов.

----------- Идентификация -----------------------------------------------------------
— это процесс при котором система узнаёт, кто перед ней, присваивая уникальный идентификатор (Логин, email) Цель — получить уникальный идентификатор. 

----------- Аутентификация ----------------------------------------------------------
— это процесс подтверждение личности пользователя или клиента перед предоставлением доступа к защищённым ресурсам API. Цель — убедиться, что идентификатор не подделан (Пароль, одноразовый код, аппаратный токен, биометрия). Виды:
	Однофакторная аутентификация (небезопасно)
	Многофакторная MFA: Двухфакторная, Трёхфакторная (безопасно)
Типы:
Методы аутентификации: 
	Токен:	
		Basic Authentication (Base64)
		Bearer token
		API Key Authentication
	Сетевые:	
		kerberos
		TLS
		OAuth/OpenID Connect
		Сертификаты

---------- Авторизация authorization — «разрешение; полномочивание» --------------------------------
 — предоставление определённому лицу или группе лиц прав, после аутентификации, на выполнение определённых действий, а также процесс проверки (подтверждения) этих прав при попытке выполнения указанных действий. Цель - ограничить доступ к ресурсам, согласно ролевой модели.
	
=========== Ролевые модели доступа ================================================================
----------- RBAC ----------------------------------------------------------------------------------
Role-Based Access Control	 — модель управления доступом, основанная на ролях пользователей в организации. Вместо индивидуального назначения привилегий каждому пользователю права доступа группируются по ролям, а пользователи получают доступ к ресурсам уже в зависимости от своей роли. Цель RBAC — централизованно контролировать права пользователей, минимизировать риски несанкционированного доступа и упрощать администрирование учётных записей.
Аналитик 	- видит отчёты;
Бухгалиер 	- доступны проводки и их отчёты;
Менеджер	- просмотр;
Администратор	- редактирование.
Студент 	- может брать книги;
Сотрудник	- редактировать.

----------- ABAC ----------------------------------------------------------------------------------
Attribute-Based Access Control	— модель управления доступом на основе атрибутов. Она определяет права доступа на основе характеристик (атрибутов) пользователя, ресурса, действия и окружения. Атрибуты могут относиться к разным категориям: 	
	Субъекты 	— пользователи, которые запрашивают доступ.
	Ресурсы 	— файлы, базы данных, API или другие системные сущности.
	Действия	— конкретная операция, которую субъект может выполнить над ресурсом (создание, чтение, обновление, удаление).
	Окружение	— контекст, в котором делается запрос на доступ (время суток, местоположение, сеть, устройство и т. д.).
Врач может видеть карту пациента, например, только:
		-в рабочие часы;
		-с рабочего места;
		-прикреплённых к нему пациентов.
Доступ к данным пользователя (клиента) только:
		-с закреплённого устройства;
		-при активном трудовом договоре.

============ Token = ключ ==================================================================================
------------ Basic Authentication...................HTTP(s)/REST-протоколы, когда пара "ключ-значение" передаются в Header: Authorization: как AuBase64. Сервер декодирует и решает дать доступ. Нет механизма отзыва доступа, кроме смены пароля. Для тестирования.;

------------ Single Page Application (SPA)..........это тип веб-приложения, которое загружает одну страницу и динамически обновляет контент в ответ на действия пользователя. В отличие от традиционных многостраничных приложений, где каждый переход между страницами требует полной перезагрузки, SPA обеспечивают плавный и непрерывный пользовательский опыт. Bearer token имеет не самый высокий уровень безопасности.

------------ Access token...........................это ваша пропускная карта в здание. Токен доступа. Она дает вам доступ в определенные помещения (ресурсы) на ограниченное время. Это основной ключ для доступа к защищенным ресурсам (например, API, данным пользователя).
	Назначение: Доказать, что у пользователя есть право доступа к определенным данным или функциям.
	Содержимое: Обычно содержит информацию о пользователе (ID, роли, "scope" — области доступа) и срок действия.
	Время жизни: Короткое — от нескольких минут до нескольких часов. Это мера безопасности. Даже если токен перехватят, злоумышленник сможет им пользоваться недолго.
	Передача: Передается клиентом (например, фронтенд-приложением) на сервер с каждым запросом к защищенному ресурсу.
	Пример:
		http
		GET /api/user/profile
		Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
		(Здесь eyJhbGci... — это и есть Access Token)

------------ Bearer token............................тип Access Token. Спец.ключ, который предоставляется пользователю сервером, после успешной аутетификации. Токен-носитель. Используется для доступа к защищённым API. Передаётся в Header: Authorization: - сервер проверяет ключ на валидность. Токен можно отозвать сервером. Мобильные приложения. Это тип этой пропускной карты, который работает по принципу "предъявительский". Тот, у кого она находится, получает доступ. Не важно, кто он. Это не отдельный тип токена, а способ его использования. Это самый распространенный тип Access Token. String - буквенно-числовой код одним блоком.
	Назначение: Определить схему аутентификации. Слово "Bearer" (предъявитель) означает, что для доступа к ресурсу достаточно просто предъявить этот токен.
	Ключевая особенность: Отсутствие криптографической проверки предъявителя. Тот, у кого есть этот токен, считается законным владельцем. Это одновременно и простота, и главный риск — если токен утек, злоумышленник может использовать его, пока он не истек.
	Стандарт: Описан в RFC 6750. Передается в заголовке Authorization: Bearer <token>.
	Вывод: Access Token часто (в 99% случаев в современных API) является Bearer Token'ом. "Bearer" — это просто уточнение, как использовать Access Token.

------------ API Key Authentication..................метод аутентификации в API, при котором клиент отправляет уникальный API-ключ вместе с каждым запросом к серверу. Это идентификатор, предоставляемый сервером клиенту для доступа к ресурсам API. Обычно это длинная алфавитно-цифровая строка, сгенерированная провайдером API и выданная разработчикам или приложениям, нуждающимся в доступе к API. По уровню безопасности = Basic Authentication. Скорость внедрения и тетсирования API.

------------ Refresh token...........................это инструмент для продления жизни сессии, позволяющий безопасно обновлять короткоживущие Access Token'ы. Токен обновления в системах авторизации, например OAuth 2.0 и OpenID Connect. Это символьная строка, которая выдаётся клиенту сервером авторизации и используется для получения нового токена доступа, когда текущий токен доступа становится недействительным или истекает его срок действия. Имеет повышенный TTL с токенами, которыми работает в паре (Access token "Bearer token"). Ближе к истечению срока действия token, по протоколу OAuth2, клиент запрашивает у сервиса аутентификации (типа Google, Yandex) новкю пару, это происходит незаметно для пользователя "под капотом". это ваш паспорт в охране. Вы не ходите с ним по офису, но когда ваша пропускная карта (Access Token) просрочилась, вы предъявляете паспорт, чтобы получить новую карту. Это долгоживущий ключ, единственная цель которого — получить новый Access Token.
	Назначение: 		Позволить пользователю получить новый Access Token без необходимости повторного ввода логина и пароля.
	Время жизни: 		Долгое — от нескольких дней до нескольких месяцев. Может быть и вовсе бессрочным, но это небезопасно.
	Хранение и передача: 	Хранится максимально безопасно (например, в httpOnly куках на клиенте) и передается только на специальный эндпоинт /token для получения новой пары токенов (Access + Refresh).
	Безопасность: 		Поскольку его время жизни велико, он гораздо ценнее для злоумышленника. Если он скомпрометирован, атакующий может получать новые Access Token'ы от имени пользователя неограниченное время.
Как они работают вместе (Типичный поток OAuth 2.0 / OpenID Connect) Вход: Пользователь вводит логин/пароль в клиентском приложении.
	Аутентификация: 	Клиент отправляет учетные данные на сервер авторизации.
	Получение токенов: 	Сервер проверяет данные и возвращает объект с двумя токенами:
	json
	{
	  "access_token": "eyJhbGci...", 	// Короткоживущий Access Token (Bearer)
	  "refresh_token": "def50200...", 	// Долгоживущий Refresh Token
	  "token_type": "Bearer",
	  "expires_in": 3600 			// Access Token истечет через час
	} 
	Доступ к API: 		Клиент использует access_token (как Bearer Token) для доступа к API.
	Истечение Access Token:	Через час (или иное время) Access Token становится недействительным. API начнет возвращать ошибку 401 Unauthorized.
	Обновление: 		Клиент не беспокоит пользователя, а отправляет refresh_token на специальный эндпоинт.
	Получение новой пары:	Сервер авторизации проверяет refresh_token и, если он валиден, выдает новую пару access_token и, иногда, новый refresh_token (ротация токена для безопасности).
	Цикл повторяется: 	Клиент снова может работать с API, используя новый access_token.
	Задачи:
		Продление сессии 		— позволяет поддерживать активную сессию пользователя, не требуя повторного ввода учётных данных.
		Повышение безопасности 		— токены доступа имеют короткий срок действия, что снижает риск их использования при утечке, а токен обновления позволяет безопасно получать новые токены доступа.
		Гибкость управления доступом 	— может использоваться для получения токенов доступа с различными областями видимости (scopes), что позволяет точно настраивать права доступа.

------------ JWT - JSON Web Token.....................Безопасный вариант ключа. Компактный и самодостаточный способ безопасной передачи информации между сторонами в виде подписанного JSON-объекта. String - буквенно-числовой код, тремя блоками, разделёнными точкой. Токен JWT состоит из трёх частей, разделённых точками: 
					Заголовок (header) 		— указывает тип токена и алгоритм подписи (например, HS256 или RS256);
					Полезная нагрузка (payload) 	— содержит утверждения (claims) — фактические данные, которые передаются в токене. Это могут быть стандартные поля и информация о пользователе; 
					Подпись (signature) 		— создаётся на основе первых двух частей и секретного ключа, который знает только сервер. Работает следующим образом:
									Пользователь 	отправляет данные для входа (логин и пароль) на сервер;
									Сервер		проверяет данные и, если всё в порядке, генерирует ключ в формате JSON, подписанный секретным ключом;
									Клиент		JWT возвращается пользователю, который хранит его (чаще всего, в localStorage или cookie). 
									Клиент		Отправляет токен в заголовке Authorization: Bearer abc123...
									Сервер		проверяет подпись и данные в ключе.
	Компактность 		— JWT представляет собой строку, которая легко передаётся через URL, заголовки HTTP или в теле запроса.
	Самодостаточность 	— весь «контекст» (например, данные о пользователе) содержится внутри токена. Можно передавать дополнительные данные, например user_id;
		Stateless	- не требует хранения состояния на сервере;
		Минусы		- нельзя отозвать (-)
		Минусы		- если ключ подписи скопроментирован, то и токены JWT можно подделать (-)

============ Протоколы =====================================================================================
------------ OAuth - Open Authorization...............это открытый стандарт авторизации, который позволяет приложениям получать ограниченный доступ к данным пользователя на других сервисах без необходимости сообщать свои логин и пароль. Простыми словами: OAuth действует как посредник от имени пользователя, предоставляя стороннему сервису (зарегистрированному на сервере, например, через: Goole, Yandex) токен доступа (access token), который разрешает передачу определённой информации об учётной записи. 

------------ Kerberos................................сетевой протокол аутентификации, разработанный в Массачусетском технологическом институте (MIT) для проекта «Афина» в конце 1980-х годов. От слова "Цербер" - трёхголовый пёс. Позволяет клиентам и серверам безопасно проверять подлинность друг друга с помощью Центра распределения ключей (KDC) — доверенной третьей стороны. Kerberos использует симметричное шифрование и обеспечивает защиту от прослушивания и повторных атак (replay attacks) в системах Windows. Для аутентификации используются временные билеты (Ticket Granting Ticket, TGT). Каждый билет принадлежит определённым реалмам, которые определяют, к каким сервисам он предоставляет доступ. Шаги протокола:
		Пользователь		вводит свой логин и пароль;
		KDC			выдаёт "билет на получение билета", TGT;
		ИС-Клиент		используя TGT запрашивает доступ к ИС-сервер у KDC;
		KDC			выдаёт TGS-Ticket Granting Service, сервисный билет;
		ИС-Клиент		предъявляет сервисный билет ИС-сервер и получает доступ без повторного ввода пароля.Особенности:
			Пароли не передаются по сети, используются временные билеты.
			Единый вход (SSO) — после получения TGT пользователь может обращаться к разным сервисам без повторной аутентификации.
			Поддержка взаимной аутентификации — не только клиент, но и сервер может проверить подлинность друг друга.

------------ TLS - Transport Layer Security..........криптографический протокол, который защищает данные во время их передачи по сети. Работает на четвёртом, транспортном, уровне сетевой модели OSI. Рукопожате-handshake. UDP-это "стеклянная" труба, TCP-это "не прозрачная" труба, шифрованный туннель. Функции TLS обеспечивает три основных аспекта безопасности: 
		Конфиденциальность — 		защита передаваемой информации от несанкционированного доступа (шифрование данных);
		Целостность — 			гарантия, что передаваемая информация не была изменена в процессе передачи;
		Аутентификация — 		проверка подлинности сторон, участвующих в коммуникации, чтобы убедиться, что общение происходит с правильным сервером, а не с злоумышленником. Работает так:
			Установление TCP-соединени;
			ИС-Клиент подключается к ИС-сервер;
			Совершается Рукопожате-handshake TLS;
			Происходит обмен ключами;
			Создаётся защищённый канал;
			после всего, по каналу- передача данных, в зашифрованном виде. Каждая "посылка" - это отдельная коробка со своим ключом.


============== Парольные политики ========================================================================================




